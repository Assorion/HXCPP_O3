// Generated by Haxe 4.3.1
#include <hxcpp.h>

#ifndef INCLUDED_BuildTool
#include <BuildTool.h>
#endif
#ifndef INCLUDED_EReg
#include <EReg.h>
#endif
#ifndef INCLUDED_Log
#include <Log.h>
#endif
#ifndef INCLUDED_Sys
#include <Sys.h>
#endif
#ifndef INCLUDED_Tools
#include <Tools.h>
#endif
#ifndef INCLUDED_cpp_Lib
#include <cpp/Lib.h>
#endif
#ifndef INCLUDED_haxe_IMap
#include <haxe/IMap.h>
#endif
#ifndef INCLUDED_haxe_ds_StringMap
#include <haxe/ds/StringMap.h>
#endif
#ifndef INCLUDED_haxe_io_Bytes
#include <haxe/io/Bytes.h>
#endif
#ifndef INCLUDED_haxe_io_Encoding
#include <haxe/io/Encoding.h>
#endif
#ifndef INCLUDED_haxe_io_Output
#include <haxe/io/Output.h>
#endif
#ifndef INCLUDED_sys_io_Process
#include <sys/io/Process.h>
#endif
#ifndef INCLUDED_sys_thread_Mutex
#include <sys/thread/Mutex.h>
#endif

HX_LOCAL_STACK_FRAME(_hx_pos_5bcedff7d06995fc_38_initMultiThreaded,"Log","initMultiThreaded",0xcb00cd88,"Log.initMultiThreaded","Log.hx",38,0x90d20cda)
HX_LOCAL_STACK_FRAME(_hx_pos_5bcedff7d06995fc_44_e,"Log","e",0x0c2115db,"Log.e","Log.hx",44,0x90d20cda)
HX_LOCAL_STACK_FRAME(_hx_pos_5bcedff7d06995fc_47_error,"Log","error",0xff41d43e,"Log.error","Log.hx",47,0x90d20cda)
HX_LOCAL_STACK_FRAME(_hx_pos_5bcedff7d06995fc_75_info,"Log","info",0xf3b470b8,"Log.info","Log.hx",75,0x90d20cda)
HX_LOCAL_STACK_FRAME(_hx_pos_5bcedff7d06995fc_93_v,"Log","v",0x0c2115ec,"Log.v","Log.hx",93,0x90d20cda)
HX_LOCAL_STACK_FRAME(_hx_pos_5bcedff7d06995fc_98_lock,"Log","lock",0xf5b0d435,"Log.lock","Log.hx",98,0x90d20cda)
HX_LOCAL_STACK_FRAME(_hx_pos_5bcedff7d06995fc_104_unlock,"Log","unlock",0x6e7c018e,"Log.unlock","Log.hx",104,0x90d20cda)
HX_LOCAL_STACK_FRAME(_hx_pos_5bcedff7d06995fc_110_print,"Log","print",0x54a360a3,"Log.print","Log.hx",110,0x90d20cda)
HX_LOCAL_STACK_FRAME(_hx_pos_5bcedff7d06995fc_119_println,"Log","println",0x4cb76de5,"Log.println","Log.hx",119,0x90d20cda)
HX_LOCAL_STACK_FRAME(_hx_pos_5bcedff7d06995fc_128_stripColor,"Log","stripColor",0xc905cb35,"Log.stripColor","Log.hx",128,0x90d20cda)
static const ::String _hx_array_data_003a0c64_10[] = {
	HX_("colors",b0,c5,86,c6),
};
HX_LOCAL_STACK_FRAME(_hx_pos_5bcedff7d06995fc_163_warn,"Log","warn",0xfceb9a90,"Log.warn","Log.hx",163,0x90d20cda)
HX_LOCAL_STACK_FRAME(_hx_pos_5bcedff7d06995fc_20_boot,"Log","boot",0xef14bc7c,"Log.boot","Log.hx",20,0x90d20cda)
HX_LOCAL_STACK_FRAME(_hx_pos_5bcedff7d06995fc_21_boot,"Log","boot",0xef14bc7c,"Log.boot","Log.hx",21,0x90d20cda)
HX_LOCAL_STACK_FRAME(_hx_pos_5bcedff7d06995fc_22_boot,"Log","boot",0xef14bc7c,"Log.boot","Log.hx",22,0x90d20cda)
HX_LOCAL_STACK_FRAME(_hx_pos_5bcedff7d06995fc_24_boot,"Log","boot",0xef14bc7c,"Log.boot","Log.hx",24,0x90d20cda)
HX_LOCAL_STACK_FRAME(_hx_pos_5bcedff7d06995fc_25_boot,"Log","boot",0xef14bc7c,"Log.boot","Log.hx",25,0x90d20cda)
HX_LOCAL_STACK_FRAME(_hx_pos_5bcedff7d06995fc_29_boot,"Log","boot",0xef14bc7c,"Log.boot","Log.hx",29,0x90d20cda)
HX_LOCAL_STACK_FRAME(_hx_pos_5bcedff7d06995fc_30_boot,"Log","boot",0xef14bc7c,"Log.boot","Log.hx",30,0x90d20cda)
HX_LOCAL_STACK_FRAME(_hx_pos_5bcedff7d06995fc_31_boot,"Log","boot",0xef14bc7c,"Log.boot","Log.hx",31,0x90d20cda)
HX_LOCAL_STACK_FRAME(_hx_pos_5bcedff7d06995fc_32_boot,"Log","boot",0xef14bc7c,"Log.boot","Log.hx",32,0x90d20cda)
HX_LOCAL_STACK_FRAME(_hx_pos_5bcedff7d06995fc_33_boot,"Log","boot",0xef14bc7c,"Log.boot","Log.hx",33,0x90d20cda)
HX_LOCAL_STACK_FRAME(_hx_pos_5bcedff7d06995fc_34_boot,"Log","boot",0xef14bc7c,"Log.boot","Log.hx",34,0x90d20cda)

void Log_obj::__construct() { }

Dynamic Log_obj::__CreateEmpty() { return new Log_obj; }

void *Log_obj::_hx_vtable = 0;

Dynamic Log_obj::__Create(::hx::DynamicArray inArgs)
{
	::hx::ObjectPtr< Log_obj > _hx_result = new Log_obj();
	_hx_result->__construct();
	return _hx_result;
}

bool Log_obj::_hx_isInstanceOf(int inClassId) {
	return inClassId==(int)0x00000001 || inClassId==(int)0x7ede50f8;
}

bool Log_obj::mute;

bool Log_obj::quiet;

bool Log_obj::verbose;

 ::Dynamic Log_obj::colorSupported;

 ::haxe::ds::StringMap Log_obj::sentWarnings;

 ::sys::thread::Mutex Log_obj::printMutex;

::String Log_obj::RED;

::String Log_obj::YELLOW;

::String Log_obj::WHITE;

::String Log_obj::NORMAL;

::String Log_obj::BOLD;

::String Log_obj::ITALIC;

void Log_obj::initMultiThreaded(){
            	HX_GC_STACKFRAME(&_hx_pos_5bcedff7d06995fc_38_initMultiThreaded)
HXDLIN(  38)		if (::hx::IsNull( ::Log_obj::printMutex )) {
HXLINE(  39)			::Log_obj::printMutex =  ::sys::thread::Mutex_obj::__alloc( HX_CTX );
            		}
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC0(Log_obj,initMultiThreaded,(void))

void Log_obj::e(::String message){
            	HX_STACKFRAME(&_hx_pos_5bcedff7d06995fc_44_e)
HXDLIN(  44)		::Log_obj::error(message,null(),null(),null());
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC1(Log_obj,e,(void))

void Log_obj::error(::String message,::String __o_verboseMessage, ::Dynamic e,::hx::Null< bool >  __o_terminate){
            		::String verboseMessage = __o_verboseMessage;
            		if (::hx::IsNull(__o_verboseMessage)) verboseMessage = HX_("",00,00,00,00);
            		bool terminate = __o_terminate.Default(true);
            	HX_STACKFRAME(&_hx_pos_5bcedff7d06995fc_47_error)
HXLINE(  48)		::String output;
HXLINE(  49)		bool _hx_tmp;
HXDLIN(  49)		if (::Log_obj::verbose) {
HXLINE(  49)			_hx_tmp = (verboseMessage != HX_("",00,00,00,00));
            		}
            		else {
HXLINE(  49)			_hx_tmp = false;
            		}
HXDLIN(  49)		if (_hx_tmp) {
HXLINE(  51)			output = ((HX_("\x1b""[31;1mError:\x1b""[0m\x1b""[1m ",5c,1a,05,73) + verboseMessage) + HX_("\x1b""[0m\n",4d,df,1c,c8));
            		}
            		else {
HXLINE(  55)			if ((message == HX_("",00,00,00,00))) {
HXLINE(  56)				output = HX_("\x1b""[31;1mError\x1b""[0m\n",3e,82,7c,b7);
            			}
            			else {
HXLINE(  58)				output = ((HX_("\x1b""[31;1mError:\x1b""[0m \x1b""[1m",d4,03,d8,29) + message) + HX_("\x1b""[0m\n",4d,df,1c,c8));
            			}
            		}
HXLINE(  60)		if (::hx::IsNotNull( ::Log_obj::printMutex )) {
HXLINE(  61)			::Log_obj::printMutex->acquire();
            		}
HXLINE(  62)		 ::haxe::io::Output _hx_tmp1 = ::Sys_obj::_hx_stderr();
HXDLIN(  62)		_hx_tmp1->write(::haxe::io::Bytes_obj::ofString(::Log_obj::stripColor(output),null()));
HXLINE(  63)		if (::hx::IsNotNull( ::Log_obj::printMutex )) {
HXLINE(  64)			::Log_obj::printMutex->release();
            		}
HXLINE(  66)		bool _hx_tmp2;
HXDLIN(  66)		bool _hx_tmp3;
HXDLIN(  66)		if (!(::Log_obj::verbose)) {
HXLINE(  66)			_hx_tmp3 = !(terminate);
            		}
            		else {
HXLINE(  66)			_hx_tmp3 = true;
            		}
HXDLIN(  66)		if (_hx_tmp3) {
HXLINE(  66)			_hx_tmp2 = ::hx::IsNotNull( e );
            		}
            		else {
HXLINE(  66)			_hx_tmp2 = false;
            		}
HXDLIN(  66)		if (_hx_tmp2) {
HXLINE(  67)			HX_STACK_DO_RETHROW(e);
            		}
HXLINE(  69)		if (terminate) {
HXLINE(  70)			::Tools_obj::exit(1);
            		}
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC4(Log_obj,error,(void))

void Log_obj::info(::String message,::String __o_verboseMessage){
            		::String verboseMessage = __o_verboseMessage;
            		if (::hx::IsNull(__o_verboseMessage)) verboseMessage = HX_("",00,00,00,00);
            	HX_STACKFRAME(&_hx_pos_5bcedff7d06995fc_75_info)
HXDLIN(  75)		if (!(::Log_obj::mute)) {
HXLINE(  77)			if (::hx::IsNotNull( ::Log_obj::printMutex )) {
HXLINE(  78)				::Log_obj::printMutex->acquire();
            			}
HXLINE(  79)			bool _hx_tmp;
HXDLIN(  79)			if (::Log_obj::verbose) {
HXLINE(  79)				_hx_tmp = (verboseMessage != HX_("",00,00,00,00));
            			}
            			else {
HXLINE(  79)				_hx_tmp = false;
            			}
HXDLIN(  79)			if (_hx_tmp) {
HXLINE(  81)				::Log_obj::println(verboseMessage);
            			}
            			else {
HXLINE(  83)				if ((message != HX_("",00,00,00,00))) {
HXLINE(  85)					::Log_obj::println(message);
            				}
            			}
HXLINE(  87)			if (::hx::IsNotNull( ::Log_obj::printMutex )) {
HXLINE(  88)				::Log_obj::printMutex->release();
            			}
            		}
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC2(Log_obj,info,(void))

void Log_obj::v(::String verboseMessage){
            	HX_STACKFRAME(&_hx_pos_5bcedff7d06995fc_93_v)
HXDLIN(  93)		::Log_obj::info(HX_("",00,00,00,00),verboseMessage);
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC1(Log_obj,v,(void))

void Log_obj::lock(){
            	HX_STACKFRAME(&_hx_pos_5bcedff7d06995fc_98_lock)
HXDLIN(  98)		if (::hx::IsNotNull( ::Log_obj::printMutex )) {
HXLINE(  99)			::Log_obj::printMutex->acquire();
            		}
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC0(Log_obj,lock,(void))

void Log_obj::unlock(){
            	HX_STACKFRAME(&_hx_pos_5bcedff7d06995fc_104_unlock)
HXDLIN( 104)		if (::hx::IsNotNull( ::Log_obj::printMutex )) {
HXLINE( 105)			::Log_obj::printMutex->release();
            		}
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC0(Log_obj,unlock,(void))

void Log_obj::print(::String message){
            	HX_STACKFRAME(&_hx_pos_5bcedff7d06995fc_110_print)
HXLINE( 111)		if (::hx::IsNotNull( ::Log_obj::printMutex )) {
HXLINE( 112)			::Log_obj::printMutex->acquire();
            		}
HXLINE( 113)		::Sys_obj::print(::Log_obj::stripColor(message));
HXLINE( 114)		if (::hx::IsNotNull( ::Log_obj::printMutex )) {
HXLINE( 115)			::Log_obj::printMutex->release();
            		}
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC1(Log_obj,print,(void))

void Log_obj::println(::String message){
            	HX_STACKFRAME(&_hx_pos_5bcedff7d06995fc_119_println)
HXLINE( 120)		if (::hx::IsNotNull( ::Log_obj::printMutex )) {
HXLINE( 121)			::Log_obj::printMutex->acquire();
            		}
HXLINE( 122)		::Sys_obj::println(::Log_obj::stripColor(message));
HXLINE( 123)		if (::hx::IsNotNull( ::Log_obj::printMutex )) {
HXLINE( 124)			::Log_obj::printMutex->release();
            		}
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC1(Log_obj,println,(void))

::String Log_obj::stripColor(::String output){
            	HX_GC_STACKFRAME(&_hx_pos_5bcedff7d06995fc_128_stripColor)
HXLINE( 129)		if (::hx::IsNull( ::Log_obj::colorSupported )) {
HXLINE( 131)			if (!(::BuildTool_obj::isWindows)) {
HXLINE( 133)				int result = -1;
HXLINE( 134)				try {
            					HX_STACK_CATCHABLE( ::Dynamic, 0);
HXLINE( 136)					 ::sys::io::Process process =  ::sys::io::Process_obj::__alloc( HX_CTX ,HX_("tput",db,22,02,4d),::Array_obj< ::String >::fromData( _hx_array_data_003a0c64_10,1),null());
HXLINE( 137)					result = ( (int)(process->exitCode(null())) );
HXLINE( 138)					process->close();
            				} catch( ::Dynamic _hx_e) {
            					if (_hx_e.IsClass<  ::Dynamic >() ){
            						HX_STACK_BEGIN_CATCH
            						 ::Dynamic _g = _hx_e;
HXLINE( 140)						{
HXLINE( 140)							null();
            						}
            					}
            					else {
            						HX_STACK_DO_THROW(_hx_e);
            					}
            				}
HXLINE( 142)				::Log_obj::colorSupported = (result == 0);
            			}
            			else {
HXLINE( 146)				bool _hx_tmp;
HXDLIN( 146)				if ((::Sys_obj::getEnv(HX_("TERM",6c,8f,ba,37)) != HX_("xterm",e4,63,0f,65))) {
HXLINE( 146)					_hx_tmp = ::hx::IsNotNull( ::Sys_obj::getEnv(HX_("ANSICON",3f,21,7f,b9)) );
            				}
            				else {
HXLINE( 146)					_hx_tmp = true;
            				}
HXDLIN( 146)				::Log_obj::colorSupported = _hx_tmp;
            			}
            		}
HXLINE( 150)		if (( (bool)(::Log_obj::colorSupported) )) {
HXLINE( 152)			return output;
            		}
            		else {
HXLINE( 156)			 ::EReg colorCodes =  ::EReg_obj::__alloc( HX_CTX ,HX_("\\x1b\\[[^m]+m",c1,5f,72,b8),HX_("g",67,00,00,00));
HXLINE( 157)			return colorCodes->replace(output,HX_("",00,00,00,00));
            		}
HXLINE( 150)		return null();
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC1(Log_obj,stripColor,return )

void Log_obj::warn(::String message,::String __o_verboseMessage,::hx::Null< bool >  __o_allowRepeat){
            		::String verboseMessage = __o_verboseMessage;
            		if (::hx::IsNull(__o_verboseMessage)) verboseMessage = HX_("",00,00,00,00);
            		bool allowRepeat = __o_allowRepeat.Default(false);
            	HX_STACKFRAME(&_hx_pos_5bcedff7d06995fc_163_warn)
HXDLIN( 163)		if (!(::Log_obj::mute)) {
HXLINE( 165)			::String output = HX_("",00,00,00,00);
HXLINE( 166)			bool _hx_tmp;
HXDLIN( 166)			if (::Log_obj::verbose) {
HXLINE( 166)				_hx_tmp = (verboseMessage != HX_("",00,00,00,00));
            			}
            			else {
HXLINE( 166)				_hx_tmp = false;
            			}
HXDLIN( 166)			if (_hx_tmp) {
HXLINE( 168)				output = ((HX_("\x1b""[33;1mWarning:\x1b""[0m \x1b""[1m",2a,58,ec,55) + verboseMessage) + HX_("\x1b""[0m",1d,fa,1d,12));
            			}
            			else {
HXLINE( 170)				if ((message != HX_("",00,00,00,00))) {
HXLINE( 172)					output = ((HX_("\x1b""[33;1mWarning:\x1b""[0m \x1b""[1m",2a,58,ec,55) + message) + HX_("\x1b""[0m",1d,fa,1d,12));
            				}
            			}
HXLINE( 175)			bool _hx_tmp1;
HXDLIN( 175)			if (!(allowRepeat)) {
HXLINE( 175)				_hx_tmp1 = ::Log_obj::sentWarnings->exists(output);
            			}
            			else {
HXLINE( 175)				_hx_tmp1 = false;
            			}
HXDLIN( 175)			if (_hx_tmp1) {
HXLINE( 177)				return;
            			}
HXLINE( 180)			::Log_obj::sentWarnings->set(output,true);
HXLINE( 182)			if (::hx::IsNotNull( ::Log_obj::printMutex )) {
HXLINE( 183)				::Log_obj::printMutex->acquire();
            			}
HXLINE( 184)			::Log_obj::println(output);
HXLINE( 185)			if (::hx::IsNotNull( ::Log_obj::printMutex )) {
HXLINE( 186)				::Log_obj::printMutex->release();
            			}
            		}
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC3(Log_obj,warn,(void))


Log_obj::Log_obj()
{
}

bool Log_obj::__GetStatic(const ::String &inName, Dynamic &outValue, ::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 1:
		if (HX_FIELD_EQ(inName,"e") ) { outValue = e_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"v") ) { outValue = v_dyn(); return true; }
		break;
	case 4:
		if (HX_FIELD_EQ(inName,"mute") ) { outValue = ( mute ); return true; }
		if (HX_FIELD_EQ(inName,"info") ) { outValue = info_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"lock") ) { outValue = lock_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"warn") ) { outValue = warn_dyn(); return true; }
		break;
	case 5:
		if (HX_FIELD_EQ(inName,"quiet") ) { outValue = ( quiet ); return true; }
		if (HX_FIELD_EQ(inName,"error") ) { outValue = error_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"print") ) { outValue = print_dyn(); return true; }
		break;
	case 6:
		if (HX_FIELD_EQ(inName,"unlock") ) { outValue = unlock_dyn(); return true; }
		break;
	case 7:
		if (HX_FIELD_EQ(inName,"verbose") ) { outValue = ( verbose ); return true; }
		if (HX_FIELD_EQ(inName,"println") ) { outValue = println_dyn(); return true; }
		break;
	case 10:
		if (HX_FIELD_EQ(inName,"printMutex") ) { outValue = ( printMutex ); return true; }
		if (HX_FIELD_EQ(inName,"stripColor") ) { outValue = stripColor_dyn(); return true; }
		break;
	case 12:
		if (HX_FIELD_EQ(inName,"sentWarnings") ) { outValue = ( sentWarnings ); return true; }
		break;
	case 14:
		if (HX_FIELD_EQ(inName,"colorSupported") ) { outValue = ( colorSupported ); return true; }
		break;
	case 17:
		if (HX_FIELD_EQ(inName,"initMultiThreaded") ) { outValue = initMultiThreaded_dyn(); return true; }
	}
	return false;
}

bool Log_obj::__SetStatic(const ::String &inName,Dynamic &ioValue,::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 4:
		if (HX_FIELD_EQ(inName,"mute") ) { mute=ioValue.Cast< bool >(); return true; }
		break;
	case 5:
		if (HX_FIELD_EQ(inName,"quiet") ) { quiet=ioValue.Cast< bool >(); return true; }
		break;
	case 7:
		if (HX_FIELD_EQ(inName,"verbose") ) { verbose=ioValue.Cast< bool >(); return true; }
		break;
	case 10:
		if (HX_FIELD_EQ(inName,"printMutex") ) { printMutex=ioValue.Cast<  ::sys::thread::Mutex >(); return true; }
		break;
	case 12:
		if (HX_FIELD_EQ(inName,"sentWarnings") ) { sentWarnings=ioValue.Cast<  ::haxe::ds::StringMap >(); return true; }
		break;
	case 14:
		if (HX_FIELD_EQ(inName,"colorSupported") ) { colorSupported=ioValue.Cast<  ::Dynamic >(); return true; }
	}
	return false;
}

#ifdef HXCPP_SCRIPTABLE
static ::hx::StorageInfo *Log_obj_sMemberStorageInfo = 0;
static ::hx::StaticInfo Log_obj_sStaticStorageInfo[] = {
	{::hx::fsBool,(void *) &Log_obj::mute,HX_("mute",d9,6e,65,48)},
	{::hx::fsBool,(void *) &Log_obj::quiet,HX_("quiet",b4,88,ed,5d)},
	{::hx::fsBool,(void *) &Log_obj::verbose,HX_("verbose",82,d7,b9,71)},
	{::hx::fsObject /*  ::Dynamic */ ,(void *) &Log_obj::colorSupported,HX_("colorSupported",4b,70,b6,7c)},
	{::hx::fsObject /*  ::haxe::ds::StringMap */ ,(void *) &Log_obj::sentWarnings,HX_("sentWarnings",0f,98,66,f8)},
	{::hx::fsObject /*  ::sys::thread::Mutex */ ,(void *) &Log_obj::printMutex,HX_("printMutex",12,e4,ed,68)},
	{::hx::fsString,(void *) &Log_obj::RED,HX_("RED",31,75,3e,00)},
	{::hx::fsString,(void *) &Log_obj::YELLOW,HX_("YELLOW",74,4b,df,82)},
	{::hx::fsString,(void *) &Log_obj::WHITE,HX_("WHITE",89,82,ab,47)},
	{::hx::fsString,(void *) &Log_obj::NORMAL,HX_("NORMAL",27,1e,ec,e2)},
	{::hx::fsString,(void *) &Log_obj::BOLD,HX_("BOLD",85,49,dc,2b)},
	{::hx::fsString,(void *) &Log_obj::ITALIC,HX_("ITALIC",f0,da,e6,b8)},
	{ ::hx::fsUnknown, 0, null()}
};
#endif

static void Log_obj_sMarkStatics(HX_MARK_PARAMS) {
	HX_MARK_MEMBER_NAME(Log_obj::mute,"mute");
	HX_MARK_MEMBER_NAME(Log_obj::quiet,"quiet");
	HX_MARK_MEMBER_NAME(Log_obj::verbose,"verbose");
	HX_MARK_MEMBER_NAME(Log_obj::colorSupported,"colorSupported");
	HX_MARK_MEMBER_NAME(Log_obj::sentWarnings,"sentWarnings");
	HX_MARK_MEMBER_NAME(Log_obj::printMutex,"printMutex");
	HX_MARK_MEMBER_NAME(Log_obj::RED,"RED");
	HX_MARK_MEMBER_NAME(Log_obj::YELLOW,"YELLOW");
	HX_MARK_MEMBER_NAME(Log_obj::WHITE,"WHITE");
	HX_MARK_MEMBER_NAME(Log_obj::NORMAL,"NORMAL");
	HX_MARK_MEMBER_NAME(Log_obj::BOLD,"BOLD");
	HX_MARK_MEMBER_NAME(Log_obj::ITALIC,"ITALIC");
};

#ifdef HXCPP_VISIT_ALLOCS
static void Log_obj_sVisitStatics(HX_VISIT_PARAMS) {
	HX_VISIT_MEMBER_NAME(Log_obj::mute,"mute");
	HX_VISIT_MEMBER_NAME(Log_obj::quiet,"quiet");
	HX_VISIT_MEMBER_NAME(Log_obj::verbose,"verbose");
	HX_VISIT_MEMBER_NAME(Log_obj::colorSupported,"colorSupported");
	HX_VISIT_MEMBER_NAME(Log_obj::sentWarnings,"sentWarnings");
	HX_VISIT_MEMBER_NAME(Log_obj::printMutex,"printMutex");
	HX_VISIT_MEMBER_NAME(Log_obj::RED,"RED");
	HX_VISIT_MEMBER_NAME(Log_obj::YELLOW,"YELLOW");
	HX_VISIT_MEMBER_NAME(Log_obj::WHITE,"WHITE");
	HX_VISIT_MEMBER_NAME(Log_obj::NORMAL,"NORMAL");
	HX_VISIT_MEMBER_NAME(Log_obj::BOLD,"BOLD");
	HX_VISIT_MEMBER_NAME(Log_obj::ITALIC,"ITALIC");
};

#endif

::hx::Class Log_obj::__mClass;

static ::String Log_obj_sStaticFields[] = {
	HX_("mute",d9,6e,65,48),
	HX_("quiet",b4,88,ed,5d),
	HX_("verbose",82,d7,b9,71),
	HX_("colorSupported",4b,70,b6,7c),
	HX_("sentWarnings",0f,98,66,f8),
	HX_("printMutex",12,e4,ed,68),
	HX_("RED",31,75,3e,00),
	HX_("YELLOW",74,4b,df,82),
	HX_("WHITE",89,82,ab,47),
	HX_("NORMAL",27,1e,ec,e2),
	HX_("BOLD",85,49,dc,2b),
	HX_("ITALIC",f0,da,e6,b8),
	HX_("initMultiThreaded",12,ec,42,50),
	HX_("e",65,00,00,00),
	HX_("error",c8,cb,29,73),
	HX_("info",6e,38,bb,45),
	HX_("v",76,00,00,00),
	HX_("lock",eb,9b,b7,47),
	HX_("unlock",c4,a2,8c,65),
	HX_("print",2d,58,8b,c8),
	HX_("println",ef,db,33,84),
	HX_("stripColor",6b,3f,1e,23),
	HX_("warn",46,62,f2,4e),
	::String(null())
};

void Log_obj::__register()
{
	Log_obj _hx_dummy;
	Log_obj::_hx_vtable = *(void **)&_hx_dummy;
	::hx::Static(__mClass) = new ::hx::Class_obj();
	__mClass->mName = HX_("Log",64,0c,3a,00);
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &Log_obj::__GetStatic;
	__mClass->mSetStaticField = &Log_obj::__SetStatic;
	__mClass->mMarkFunc = Log_obj_sMarkStatics;
	__mClass->mStatics = ::hx::Class_obj::dupFunctions(Log_obj_sStaticFields);
	__mClass->mMembers = ::hx::Class_obj::dupFunctions(0 /* sMemberFields */);
	__mClass->mCanCast = ::hx::TCanCast< Log_obj >;
#ifdef HXCPP_VISIT_ALLOCS
	__mClass->mVisitFunc = Log_obj_sVisitStatics;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = Log_obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = Log_obj_sStaticStorageInfo;
#endif
	::hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

void Log_obj::__boot()
{
{
            	HX_STACKFRAME(&_hx_pos_5bcedff7d06995fc_20_boot)
HXDLIN(  20)		mute = false;
            	}
{
            	HX_STACKFRAME(&_hx_pos_5bcedff7d06995fc_21_boot)
HXDLIN(  21)		quiet = false;
            	}
{
            	HX_STACKFRAME(&_hx_pos_5bcedff7d06995fc_22_boot)
HXDLIN(  22)		verbose = false;
            	}
{
            	HX_STACKFRAME(&_hx_pos_5bcedff7d06995fc_24_boot)
HXDLIN(  24)		colorSupported = null();
            	}
{
            	HX_GC_STACKFRAME(&_hx_pos_5bcedff7d06995fc_25_boot)
HXDLIN(  25)		sentWarnings =  ::haxe::ds::StringMap_obj::__alloc( HX_CTX );
            	}
{
            	HX_STACKFRAME(&_hx_pos_5bcedff7d06995fc_29_boot)
HXDLIN(  29)		RED = HX_("\x1b""[31m",2f,f2,1e,c8);
            	}
{
            	HX_STACKFRAME(&_hx_pos_5bcedff7d06995fc_30_boot)
HXDLIN(  30)		YELLOW = HX_("\x1b""[33m",ed,f3,1e,c8);
            	}
{
            	HX_STACKFRAME(&_hx_pos_5bcedff7d06995fc_31_boot)
HXDLIN(  31)		WHITE = HX_("\x1b""[37m",69,f7,1e,c8);
            	}
{
            	HX_STACKFRAME(&_hx_pos_5bcedff7d06995fc_32_boot)
HXDLIN(  32)		NORMAL = HX_("\x1b""[0m",1d,fa,1d,12);
            	}
{
            	HX_STACKFRAME(&_hx_pos_5bcedff7d06995fc_33_boot)
HXDLIN(  33)		BOLD = HX_("\x1b""[1m",fc,fa,1d,12);
            	}
{
            	HX_STACKFRAME(&_hx_pos_5bcedff7d06995fc_34_boot)
HXDLIN(  34)		ITALIC = HX_("\x1b""[3m",ba,fc,1d,12);
            	}
}

